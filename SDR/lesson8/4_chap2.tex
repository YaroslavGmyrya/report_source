\chapter{Практическая часть}
\label{ch:chap2}

\section{\textbf{Введение}}

На прошлом занятии мы формировали собственные семплы, используя BPSK/QPSK модуляцию. Мы использовали формирующий фильтр, имеющий
импульсную характеристику прямоугольной формы. Прямоугольная импульсная характеристика не используется в реальном оборудовании, потому 
что прямоугольный сигнал будет занимать слишком много спектра. На этом занятии зададим для формирующего фильтра импульсную характеристику
с формой приподнятого косинуса. Такая форма может использоваться в реальном оборудовании.

\section{\textbf{Приподнятый косинус}}

Формула приподнятого косинуса имеет вид:

$$\frac{cos(\frac{\pi \alpha t}{T})}{1-(\frac{2\alpha t}{T})^2}$$

Здесь $t$ - номер отсчета, $T$ - период, $\alpha \in [0;1]$ - некоторый параметр. \\

$\alpha$ определяет полосу пропускания, занимаемую импульсом и скорость, с
которой затухают хвосты импульса. При $\alpha$ = 0 самая узкая полоса пропускания и самая низкая
полоса затухания. Для $\alpha$ = 1 все наоборот. Чем меньше $\alpha$ тем сильнее уменьшается межсимвольная
интерференция, но возрастает чувствительность к джиттеру. Для беспроводной передачи данных
берут $0.2 \leq  \alpha \leq 0.3$. \\

При помощи скрипта на Python визуализируем приподнятый косинус и выполним операцию свертки над
приподнятым косинусом и прямоугольным сигналом.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{plot.png}
    \caption{Приподнятый косинус}
\end{figure}

Видим, что после операции свертки получили новый сигнал, который имеет свойства обоих: он имеет форму приподнятого косинуса,
но в то же время растянут, как прямоугольный.

\section{\textbf{Создание импульсной характеристики}}

Будем использовать приподнятый косинус с параметри $\alpha$ = 0.25, $t in [-5;5)$ (т.к мы используем 10 семплов на символ), $T = 0.25$.

\begin{lstlisting}
#define T 0.25
#define ALPHA 0.25

int main(){
    FILE* qpsk_samples = fopen("qpsk_samples.pcm", "w");

    //impulse response
    double g[SAMPLES_ON_BIT];

    for(int i = 0; i < SAMPLES_ON_BIT; ++i){
        int t = i - SAMPLES_ON_BIT/2;
        g[i] = cos((M_PI * ALPHA * t) / T) / (1 - pow((2*ALPHA*t/T), 2));
    }

    //translate char to bits
    int bits_count = 0;
    uint8_t* bits = stob(MESSAGE, &bits_count);

    //translate bits to symbols (I, Q)
    int symbols_count = 0;
    int* symbols = QPSK_modulation(bits, bits_count, &symbols_count); 

    //translate IQ to upsampling IQ
    int ups_symbols_count = 0;
    int* ups_symbols = upsampling(symbols, symbols_count, SAMPLES_ON_BIT, &ups_symbols_count);

    //transalte upsampling IQ to samples
    int samples_count = 0;
    int16_t* samples = ps_filter(ups_symbols, ups_symbols_count, SAMPLES_ON_BIT, g, &samples_count);

    //write samples to file
    fwrite(samples, samples_count * sizeof(int16_t), 1, qpsk_samples);

    fclose(qpsk_samples);
    return 0;
}
\end{lstlisting}

В цикле заполняем импульсную характеристику значениями, посчитанными по формуле. $t$ выбираем
таким, чтобы график был симметричен относительно оси Y.

\section{\textbf{Передача семплов и анализ результатов}}

Передадим сформированные с помощью QPSK символы и посмотрим, как выглядит наш сигнал на передаче.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{tx.png}
    \caption{Сигнал на передаче}
\end{figure}

Можем заметить, что сигнал больше не имеет прямоугольную форму, а имеет форму приподнятого косинуса, но из-за малого количества
отсчетов для импульсной характеристики сигнал выглядит ломанным. Также можно заметить, что изменилось сигнальное созвездие, потому
что теперь сигнал принимает не только значения [-1,0,1], но все равно сигнальное созвездие схоже с QPSK созвездием. \\

Изобразим сигнал на приеме:

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{rx.png}
    \caption{Сигнал на приеме}
\end{figure}

Сигнал сильно исказился, но он все равно похож на приподнятый косинус. Сигнальное созвездие
тоже исказилось, но остается похожим на сигнальное созвездие QPSK.


\endinput
